use std::error::Error;
use std::fs;
use object::File;
use object::Object;
use object::ObjectSection;

pub fn replace_url_in_exe_rdata(input_path: &str, output_path: &str, payload: &str) -> Result<(), Box<dyn Error>> {
    let mut data = fs::read(input_path)?;
    
    // 解析PE文件
    let file = File::parse(&*data)?;
    let payload_section = file.section_by_name(".rdata")
        .ok_or_else(|| Err::<(), Box<std::io::Error>>(Box::new(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "没有找到.rdata段"
            )))).unwrap();

    let (section_offset, section_size) = payload_section.file_range()
        .ok_or("Section has no physical storage")?;
    
    let start = section_offset as usize;
    let end = start + section_size as usize;

    if end > data.len() {
        return Err("Section exceeds file size".into());
    }

    // 生成搜索模式（小端序）
    let pattern_u16 = vec![0x0058u16; 16]; // 32字节的填充
    let pattern_bytes: Vec<u8> = pattern_u16
        .iter()
        .flat_map(|c| c.to_le_bytes()) // 转换为小端字节序列
        .collect();

    // 在二进制数据中搜索字节模式
    let offset = data[start..end]
        .windows(pattern_bytes.len())
        .position(|window| window == pattern_bytes)
        .ok_or("Pattern not found")?;

    let write_pos = start + offset;

    let utf16_payload: Vec<u16> = payload.encode_utf16().collect();
    let mut payload_bytes = Vec::with_capacity(utf16_payload.len() * 2);
    for &c in &utf16_payload {
        payload_bytes.extend_from_slice(&c.to_le_bytes());
    }

    let max_len = 32.min(payload_bytes.len());
    data[write_pos..write_pos + max_len].copy_from_slice(&payload_bytes[..max_len]);
    
    // 填充剩余空间（可选）
    if max_len < 32 {
        data[write_pos + max_len..write_pos + 32].fill(0);
    }

    fs::write(output_path, &data)?;
    Ok(())
}

